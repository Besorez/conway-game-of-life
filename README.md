# Conway's Game of Life (Life 1.06, int64 coordinates)

This repository contains a C++ console program that implements Conway's Game of Life on an effectively unbounded 2D grid using signed 64-bit coordinates.

The program:
- reads the initial set of live cells from standard input in Life 1.06 format
- runs exactly 10 iterations
- prints the final set of live cells to standard output in the Life 1.06 format

Important I/O contract:
- stdout is reserved strictly for Life 1.06 data (machine-readable)
- diagnostics and progress logs go to stderr (human-readable)

## Problem statement recap

We model an infinite 2D grid. Each cell at (x, y) is alive or dead. Each iteration updates all cells simultaneously using the 8 surrounding neighbors (Moore neighborhood).

Rules:
- Alive cell with fewer than 2 alive neighbors dies
- Alive cell with 2 or 3 alive neighbors survives
- Alive cell with more than 3 alive neighbors dies
- Dead cell with exactly 3 alive neighbors becomes alive

Coordinates are signed 64-bit integers. The board is conceptually unbounded, so the implementation must be sparse (no 2D array).

The program is required to run exactly 10 iterations.

## Input format (Life 1.06)

stdin must contain:
1) header line
#Life 1.06

2) then one live cell per line
x y

Example:
#Life 1.06
0 1
1 2
2 0
2 1
2 2
-2000000000000 -2000000000000
-2000000000001 -2000000000001
-2000000000000 -2000000000001

Notes:
- duplicates are allowed and will be naturally de-duplicated by the internal set
- empty lines are allowed
- comment lines starting with '#' are allowed (the header is also a comment line)

## Output format (Life 1.06)

stdout:
#Life 1.06
x y
x y
...

Output is deterministic:
- coordinates are sorted by Y, then X

This makes diffs stable and simplifies automated comparison.

## High level design

### 1) Sparse state: store only alive cells

The simulation state is:
- LifeIO::FAliveSet = unordered_set<FCellCoord>

FCellCoord stores:
- int64 X
- int64 Y

This avoids allocating a grid and supports large coordinate magnitudes.

### 2) Candidate evaluation via neighbor counting

Computing a full step over an infinite grid is impossible. Instead, we evaluate only candidate cells that can possibly change:
- any cell that is a neighbor of a currently alive cell

Algorithm per step:
1) For each alive cell, visit its 8 neighbors and increment a neighbor count for those neighbor coordinates
2) For each candidate cell in the neighbor-count map:
   - check whether it was alive in the current set
   - apply Life rules using the neighbor count
   - if it should be alive, insert it into the next set

This is the standard sparse approach for Game of Life.

### 3) Explicit neighbor offsets, no nested dy/dx loops

Neighbor iteration uses a fixed list of 8 offsets:
(-1, -1), (0, -1), (1, -1),
(-1,  0),         (1,  0),
(-1,  1), (0,  1), (1,  1)

This removes the common triple-nested pattern and makes the code easier to test and review.

### 4) Safe int64 neighbor generation

When generating a neighbor coordinate for X or Y we must avoid signed overflow at int64 limits.

The implementation:
- performs a checked add for delta in {-1, 0, +1}
- if adding would overflow, the neighbor is skipped

This keeps behavior well-defined even at INT64_MIN and INT64_MAX.

### 5) Reuse buffers per step

FLifeSimulator owns a neighbor-count map as a member:
- it is cleared and reused every step
- reserve is based on current alive count * 8

This reduces per-step allocations and keeps runtime stable.

## Complexity

Let L be the number of alive cells.

Per step:
- visits each alive cell once
- touches up to 8 neighbor positions per alive cell
- processes the set of candidate cells (at most 8*L, often less due to overlap)

Typical average-case complexity per step:
- time: O(L)
- memory: O(L)

All operations rely on hash tables with typical average O(1) behavior.

## Project structure

conway-game-of-life/
  GameOfLife.sln
  GameOfLife.vcxproj
  Source/
    Main.cpp
    CellCoord.h
    LifeLog.h
    LifeIO.h
    LifeIO.cpp
    LifeSim.h
    LifeSim.cpp
  samples/
    input.txt
    output.txt            (generated by run_debug.bat)
  run_debug.bat
  README.md

## Build instructions

### Visual Studio 2022
1) Open GameOfLife.sln
2) Select configuration: Debug | x64 (or Release | x64)
3) Build: Build -> Build Solution

## Run instructions

### Spec-compliant run (stdin/stdout)

From the repository root:
x64\Debug\GameOfLife.exe < samples\input.txt > samples\output.txt

This satisfies the task requirement: read stdin, write stdout.

### Local demo run (preview)

From the repository root:
run_debug.bat

The script:
- runs the executable using samples/input.txt
- writes samples/output.txt
- prints input and output previews (first N lines)
- prints a small summary (alive count in vs out)

## What to expect

### Output size may increase
It is normal for the number of alive cells to increase after iterations due to the birth rule:
- dead cell with exactly 3 alive neighbors becomes alive

Many patterns grow before stabilizing, oscillating, or expanding.

### Deterministic output order
The program sorts output by Y then X, so the printed order is stable across runs.

### Logs
The program can log parse stats and iteration progress to stderr.
stdout remains clean so automated checkers can parse Life 1.06 output without noise.

## Testing suggestions

### 1) Smoke test with provided sample
- Put an input pattern into samples/input.txt
- Run run_debug.bat
- Inspect samples/output.txt

### 2) Known Life patterns

Block (still life): should remain unchanged
#Life 1.06
0 0
1 0
0 1
1 1

Blinker (oscillator): period 2
#Life 1.06
0 0
1 0
2 0

Glider: moves diagonally over time

### 3) Edge safety test (int64 limits)
Place cells at INT64_MAX and INT64_MIN boundaries and confirm:
- program does not overflow or crash
- neighbors that would overflow are skipped

## Code walkthrough

- LifeIO
  - parses Life 1.06 input from stdin
  - writes Life 1.06 output to stdout
  - enforces header and supports comments/blank lines
  - outputs deterministically sorted coordinates

- FLifeSimulator (LifeSim)
  - performs one simulation step using sparse neighbor counting
  - uses explicit neighbor offsets (8)
  - uses checked int64 neighbor generation
  - reuses internal buffers for performance stability

- Main.cpp
  - reads input
  - runs exactly 10 iterations
  - prints final state in Life 1.06 format
